var THREECapsuleBufferGeometry=function(t,e){"use strict";class r extends e.BufferGeometry{constructor(t,r,o,s,a,n,i,u,c){super(),this.type="CapsuleBufferGeometry",this.parameters={radiusTop:t,radiusBottom:r,height:o,radialSegments:s,heightSegments:a,thetaStart:u,thetaLength:c},t=void 0!==t?t:1,r=void 0!==r?r:1,o=void 0!==o?o:2,s=Math.floor(s)||8,a=Math.floor(a)||1,n=Math.floor(n)||2,i=Math.floor(i)||2,u=void 0!==u?u:0,c=void 0!==c?c:2*Math.PI;var l=Math.acos((r-t)/o),h=(s+1)*(a+1+i+n),f=s*(a+i+n)*2*3,y=new e.BufferAttribute(new(f>65535?Uint32Array:Uint16Array)(f),1),M=new e.BufferAttribute(new Float32Array(3*h),3),w=new e.BufferAttribute(new Float32Array(3*h),3),d=new e.BufferAttribute(new Float32Array(2*h),2),p=0,m=0,V=[],x=o/2;!function(){var h,f,v=new e.Vector3,z=new e.Vector3,b=Math.cos(l),X=Math.sin(l),A=new e.Vector2(t*X,x+t*b).sub(new e.Vector2(r*X,r*b-x)).length(),B=t*l+A+r*(Math.PI/2-l),E=0;for(f=0;f<=n;f++){var Y=[],P=Math.PI/2-l*(f/n);E+=t*l/n;var T=Math.cos(P),G=Math.sin(P),g=T*t;for(h=0;h<=s;h++){var I=(F=h/s)*c+u,R=Math.sin(I),S=Math.cos(I);z.x=g*R,z.y=x+G*t,z.z=g*S,M.setXYZ(p,z.x,z.y,z.z),v.set(T*R,G,T*S),w.setXYZ(p,v.x,v.y,v.z),d.setXY(p,F,1-E/B),Y.push(p),p++}V.push(Y)}var Z=o+b*t-b*r,C=X*(r-t)/Z;for(f=1;f<=a;f++){Y=[];E+=A/a;g=X*(f*(r-t)/a+t);for(h=0;h<=s;h++){I=(F=h/s)*c+u,R=Math.sin(I),S=Math.cos(I);z.x=g*R,z.y=x+b*t-f*Z/a,z.z=g*S,M.setXYZ(p,z.x,z.y,z.z),v.set(R,C,S).normalize(),w.setXYZ(p,v.x,v.y,v.z),d.setXY(p,F,1-E/B),Y.push(p),p++}V.push(Y)}for(f=1;f<=i;f++){Y=[],P=Math.PI/2-l-(Math.PI-l)*(f/i);E+=r*l/i;T=Math.cos(P),G=Math.sin(P),g=T*r;for(h=0;h<=s;h++){var F;I=(F=h/s)*c+u,R=Math.sin(I),S=Math.cos(I);z.x=g*R,z.y=G*r-x,z.z=g*S,M.setXYZ(p,z.x,z.y,z.z),v.set(T*R,G,T*S),w.setXYZ(p,v.x,v.y,v.z),d.setXY(p,F,1-E/B),Y.push(p),p++}V.push(Y)}for(h=0;h<s;h++)for(f=0;f<n+a+i;f++){var H=V[f][h],U=V[f+1][h],k=V[f+1][h+1],Q=V[f][h+1];y.setX(m,H),m++,y.setX(m,U),m++,y.setX(m,Q),m++,y.setX(m,U),m++,y.setX(m,k),m++,y.setX(m,Q),m++}}(),this.setIndex(y),this.setAttribute("position",M),this.setAttribute("normal",w),this.setAttribute("uv",d)}static fromPoints(t,o,s,a,n,i,u,c,l,h){let f=null,y=null,M=null,w=null;y=t,f=o,w=s,M=a;const d=f,p=y,m=M,V=w,x=new e.Vector3(d.x,d.y,d.z),v=new e.Vector3(p.x,p.y,p.z),z=m,b=V;let X=x.distanceTo(v);if(X<Math.abs(m-V)){let t=new e.SphereBufferGeometry(V,n,c,l,h);return t.translate(V.x,V.y,V.z),t}const A=Math.acos((b-z)/X),B=Math.cos(A),E=new e.Matrix4,Y=new e.Quaternion,P=new e.Vector3(0,1,0),T=new e.Vector3;T.subVectors(x,v),T.normalize(),Y.setFromUnitVectors(P,T),E.makeRotationFromQuaternion(Y);const G=new e.Matrix4,g=new e.Vector3;g.subVectors(x,v),g.normalize();let I=new e.Vector3;I=x,I.addScaledVector(g,B*z);let R=new e.Vector3;R=v,R.addScaledVector(g,B*b);const S=new e.Vector3;S.subVectors(R,I),S.normalize();const Z=new e.Vector3;Z.lerpVectors(R,I,.5),G.makeTranslation(Z.x,Z.y,Z.z);let C=new r(b,z,X,n,i,u,c,l,h);return C.applyMatrix(E),C.applyMatrix(G),C}}return function(t,e){if(void 0!==THREE[t]){if(THREE[t]!==e){throw`CapsuleBufferGeometry: ${t} is duplicated. Your bundle includes ${t} twice. Please repair your bundle.`}}else THREE[t]=e}("CapsuleBufferGeometry",r),t.CapsuleBufferGeometry=r,Object.defineProperty(t,"__esModule",{value:!0}),t}({},THREE);
