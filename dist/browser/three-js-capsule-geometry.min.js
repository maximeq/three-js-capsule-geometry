!(function(t, e) {
"object" == typeof exports && "undefined" != typeof module
? (module.exports = e(require("three")))
: "function" == typeof define && define.amd
? define(["three"], e)
: (t.THREECapsuleBufferGeometry = e(t.THREE));
})(this, function(t) {
"use strict";
function e(e, r, o, a, n, s, i, u, h) {
t.BufferGeometry.call(this),
(this.type = "CapsuleBufferGeometry"),
(this.parameters = {
radiusTop: e,
radiusBottom: r,
height: o,
radialSegments: a,
heightSegments: n,
thetaStart: u,
thetaLength: h
}),
(e = void 0 !== e ? e : 1),
(r = void 0 !== r ? r : 1),
(o = void 0 !== o ? o : 2),
(a = Math.floor(a) || 8),
(n = Math.floor(n) || 1),
(s = Math.floor(s) || 2),
(i = Math.floor(i) || 2),
(u = void 0 !== u ? u : 0),
(h = void 0 !== h ? h : 2 * Math.PI);
var c = Math.acos((r - e) / o),
f = (a + 1) * (n + 1 + i + s),
l = a * (n + i + s) * 2 * 3,
y = new t.BufferAttribute(new (l > 65535 ? Uint32Array : Uint16Array)(l), 1),
p = new t.BufferAttribute(new Float32Array(3 * f), 3),
M = new t.BufferAttribute(new Float32Array(3 * f), 3),
w = new t.BufferAttribute(new Float32Array(2 * f), 2),
d = 0,
m = 0,
v = [],
x = o / 2;
!(function() {
var f,
l,
V = new t.Vector3(),
z = new t.Vector3(),
X = Math.cos(c),
b = Math.sin(c),
A = new t.Vector2(e * b, x + e * X)
.sub(new t.Vector2(r * b, r * X - x))
.length(),
B = e * c + A + r * (Math.PI / 2 - c),
Y = 0;
for (l = 0; l <= s; l++) {
var P = [],
g = Math.PI / 2 - c * (l / s);
Y += (e * c) / s;
var E = Math.cos(g),
G = Math.sin(g),
I = E * e;
for (f = 0; f <= a; f++) {
var S = f / a,
T = S * h + u,
Z = Math.sin(T),
F = Math.cos(T);
(z.x = I * Z),
(z.y = x + G * e),
(z.z = I * F),
p.setXYZ(d, z.x, z.y, z.z),
V.set(E * Z, G, E * F),
M.setXYZ(d, V.x, V.y, V.z),
w.setXY(d, S, 1 - Y / B),
P.push(d),
d++;
}
v.push(P);
}
var R = o + X * e - X * r,
C = (b * (r - e)) / R;
for (l = 1; l <= n; l++) {
var P = [];
Y += A / n;
var I = b * ((l * (r - e)) / n + e);
for (f = 0; f <= a; f++) {
var S = f / a,
T = S * h + u,
Z = Math.sin(T),
F = Math.cos(T);
(z.x = I * Z),
(z.y = x + X * e - (l * R) / n),
(z.z = I * F),
p.setXYZ(d, z.x, z.y, z.z),
V.set(Z, C, F).normalize(),
M.setXYZ(d, V.x, V.y, V.z),
w.setXY(d, S, 1 - Y / B),
P.push(d),
d++;
}
v.push(P);
}
for (l = 1; l <= i; l++) {
var P = [],
g = Math.PI / 2 - c - (Math.PI - c) * (l / i);
Y += (r * c) / i;
var E = Math.cos(g),
G = Math.sin(g),
I = E * r;
for (f = 0; f <= a; f++) {
var S = f / a,
T = S * h + u,
Z = Math.sin(T),
F = Math.cos(T);
(z.x = I * Z),
(z.y = G * r - x),
(z.z = I * F),
p.setXYZ(d, z.x, z.y, z.z),
V.set(E * Z, G, E * F),
M.setXYZ(d, V.x, V.y, V.z),
w.setXY(d, S, 1 - Y / B),
P.push(d),
d++;
}
v.push(P);
}
for (f = 0; f < a; f++)
for (l = 0; l < s + n + i; l++) {
var H = v[l][f],
U = v[l + 1][f],
j = v[l + 1][f + 1],
k = v[l][f + 1];
y.setX(m, H),
m++,
y.setX(m, U),
m++,
y.setX(m, k),
m++,
y.setX(m, U),
m++,
y.setX(m, j),
m++,
y.setX(m, k),
m++;
}
})(),
this.setIndex(y),
this.setAttribute("position", p),
this.setAttribute("normal", M),
this.setAttribute("uv", w);
}
(t = t && t.hasOwnProperty("default") ? t.default : t),
(e.prototype = Object.create(t.BufferGeometry.prototype)),
(e.prototype.constructor = e),
(e.fromPoints = function(r, o, a, n, s, i, u, h, c, f) {
let l = null,
y = null,
p = null,
M = null;
const w = (l = o),
d = (y = r),
m = (p = n),
v = (M = a),
x = new t.Vector3(w.x, w.y, w.z),
V = new t.Vector3(d.x, d.y, d.z),
z = m,
X = v;
let b = x.distanceTo(V);
if (b < Math.abs(m - v)) {
let e = new t.SphereBufferGeometry(v, s, h, c, f);
return e.translate(v.x, v.y, v.z), e;
}
const A = Math.acos((X - z) / b),
B = Math.cos(A),
Y = new t.Matrix4(),
P = new t.Quaternion(),
g = new t.Vector3(0, 1, 0),
E = new t.Vector3();
E.subVectors(x, V),
E.normalize(),
P.setFromUnitVectors(g, E),
Y.makeRotationFromQuaternion(P);
const G = new t.Matrix4(),
I = new t.Vector3();
I.subVectors(x, V), I.normalize();
let S = new t.Vector3();
(S = x).addScaledVector(I, B * z);
let T = new t.Vector3();
(T = V).addScaledVector(I, B * X);
const Z = new t.Vector3();
Z.subVectors(T, S), Z.normalize();
const F = new t.Vector3();
F.lerpVectors(T, S, 0.5), G.makeTranslation(F.x, F.y, F.z);
let R = new e(X, z, b, s, i, u, h, c, f);
return R.applyMatrix(Y), R.applyMatrix(G), R;
});
var r = e;
return (THREE.CapsuleBufferGeometry = r), r;
});
